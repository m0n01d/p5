// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as PlotterFrame from "./PlotterFrame.res.mjs";

var tileColors = [
  [
    240,
    240,
    240
  ],
  [
    100,
    150,
    255
  ],
  [
    255,
    100,
    100
  ],
  [
    100,
    255,
    150
  ]
];

var adjacencyRules = [
  [
    [
      0,
      1,
      2,
      3
    ],
    [
      0,
      1,
      2,
      3
    ],
    [
      0,
      1,
      2,
      3
    ],
    [
      0,
      1,
      2,
      3
    ]
  ],
  [
    [
      0,
      1,
      3
    ],
    [
      1,
      3
    ],
    [
      0,
      1,
      3
    ],
    [
      1,
      3
    ]
  ],
  [
    [
      2,
      3
    ],
    [
      0,
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      0,
      2,
      3
    ]
  ],
  [
    [
      2,
      3
    ],
    [
      1,
      3
    ],
    [
      2,
      3
    ],
    [
      1,
      3
    ]
  ]
];

function createGrid(gridSize) {
  return Core__Array.make(gridSize, undefined).map(function () {
              return Core__Array.make(gridSize, undefined).map(function () {
                          return {
                                  index: -1,
                                  options: [
                                    0,
                                    1,
                                    2,
                                    3
                                  ]
                                };
                        });
            });
}

function getMinEntropyTile(grid) {
  var minEntropy = {
    contents: 999
  };
  var minPos = {
    contents: undefined
  };
  grid.forEach(function (row, y) {
        row.forEach(function (tile, x) {
              if (!(tile.index === -1 && tile.options.length > 0)) {
                return ;
              }
              var entropy = tile.options.length;
              if (entropy < minEntropy.contents) {
                minEntropy.contents = entropy;
                minPos.contents = [
                  x,
                  y
                ];
                return ;
              }
              
            });
      });
  return minPos.contents;
}

function collapseTile(tile, p) {
  if (tile.options.length === 0) {
    return tile;
  }
  var randomIndex = p.random(tile.options.length) | 0;
  var chosenOption = Core__Option.getOr(tile.options[randomIndex], 0);
  return {
          index: chosenOption,
          options: [chosenOption]
        };
}

function propagateConstraints(grid, x, y) {
  var newGrid = grid.map(function (row) {
        return row.map(function (tile) {
                    return tile;
                  });
      });
  var gridSize = grid.length;
  var centerTile = Core__Option.flatMap(grid[y], (function (row) {
          return row[x];
        }));
  if (centerTile === undefined) {
    return newGrid;
  }
  if (centerTile.index === -1) {
    return newGrid;
  }
  var tileIndex = centerTile.index;
  var rules = Core__Option.getOr(adjacencyRules[tileIndex], [
        [0],
        [0],
        [0],
        [0]
      ]);
  if (y > 0) {
    Core__Option.map(newGrid[y - 1 | 0], (function (row) {
            var neighbor = Core__Option.getOr(row[x], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[0], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  if (x < (gridSize - 1 | 0)) {
    Core__Option.map(newGrid[y], (function (row) {
            var neighbor = Core__Option.getOr(row[x + 1 | 0], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x + 1 | 0] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[1], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  if (y < (gridSize - 1 | 0)) {
    Core__Option.map(newGrid[y + 1 | 0], (function (row) {
            var neighbor = Core__Option.getOr(row[x], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[2], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  if (x > 0) {
    Core__Option.map(newGrid[y], (function (row) {
            var neighbor = Core__Option.getOr(row[x - 1 | 0], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x - 1 | 0] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[3], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  return newGrid;
}

function drawTile(p, tile, x, y, size) {
  p.stroke(0);
  p.strokeWeight(1);
  p.noFill();
  p.rect(x, y, size, size);
  if (tile.index === -1) {
    return ;
  }
  var match = tile.index;
  switch (match) {
    case 1 :
        p.line(x, y + size / 2.0, x + size, y + size / 2.0);
        return ;
    case 2 :
        p.line(x + size / 2.0, y, x + size / 2.0, y + size);
        return ;
    case 3 :
        p.line(x, y + size / 2.0, x + size, y + size / 2.0);
        p.line(x + size / 2.0, y, x + size / 2.0, y + size);
        return ;
    default:
      return ;
  }
}

var wfcState = {
  contents: {
    grid: createGrid(20),
    gridSize: 20,
    cellSize: 0.0,
    collapsed: false
  }
};

function draw(p, paperSize) {
  var availableWidth = paperSize.width - 30.0 * 2.0;
  var availableHeight = paperSize.height - 30.0 * 2.0;
  var minDimension = Math.min(availableWidth, availableHeight);
  var cellSize = minDimension / 20;
  var startX = (paperSize.width - cellSize * 20) / 2.0;
  var startY = (paperSize.height - cellSize * 20) / 2.0;
  if (wfcState.contents.cellSize !== cellSize) {
    wfcState.contents = {
      grid: createGrid(20),
      gridSize: 20,
      cellSize: cellSize,
      collapsed: false
    };
    p.frameRate(1200.0);
  }
  var grid = wfcState.contents.grid;
  grid.forEach(function (row, y) {
        row.forEach(function (tile, x) {
              var xPos = startX + x * cellSize;
              var yPos = startY + y * cellSize;
              drawTile(p, tile, xPos, yPos, cellSize);
            });
      });
  if (wfcState.contents.collapsed) {
    return ;
  }
  var match = getMinEntropyTile(grid);
  if (match !== undefined) {
    var y = match[1];
    var x = match[0];
    var tile = Core__Option.getOr(Core__Option.flatMap(grid[y], (function (row) {
                return row[x];
              })), {
          index: -1,
          options: []
        });
    var newTile = collapseTile(tile, p);
    var newGrid = grid.map(function (row, rowY) {
          if (rowY === y) {
            return row.map(function (t, colX) {
                        if (colX === x) {
                          return newTile;
                        } else {
                          return t;
                        }
                      });
          } else {
            return row;
          }
        });
    var propagatedGrid = propagateConstraints(newGrid, x, y);
    var init = wfcState.contents;
    wfcState.contents = {
      grid: propagatedGrid,
      gridSize: init.gridSize,
      cellSize: init.cellSize,
      collapsed: init.collapsed
    };
    return ;
  }
  var init$1 = wfcState.contents;
  wfcState.contents = {
    grid: init$1.grid,
    gridSize: init$1.gridSize,
    cellSize: init$1.cellSize,
    collapsed: true
  };
  console.log("WFC complete!");
}

var createSketch = PlotterFrame.createPlotterSketch(draw);

export {
  tileColors ,
  adjacencyRules ,
  createGrid ,
  getMinEntropyTile ,
  collapseTile ,
  propagateConstraints ,
  drawTile ,
  wfcState ,
  draw ,
  createSketch ,
}
/* wfcState Not a pure module */
