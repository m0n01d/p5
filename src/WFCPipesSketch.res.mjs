// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Float from "@rescript/core/src/Core__Float.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as PlotterFrame from "./PlotterFrame.res.mjs";

var state = {
  contents: {
    pipeThickness: 12.0,
    gridSize: 8,
    gapSize: 6.0,
    numLayers: 3,
    curviness: 0.5,
    stretchiness: 1.0
  }
};

var tiles = [
  {
    id: 0,
    edges: [
      "A",
      "B",
      "A",
      "B"
    ],
    connections: [
      "Up",
      "Down"
    ]
  },
  {
    id: 1,
    edges: [
      "B",
      "A",
      "B",
      "A"
    ],
    connections: [
      "Left",
      "Right"
    ]
  },
  {
    id: 2,
    edges: [
      "A",
      "A",
      "B",
      "B"
    ],
    connections: [
      "Down",
      "Right"
    ]
  },
  {
    id: 3,
    edges: [
      "A",
      "B",
      "B",
      "A"
    ],
    connections: [
      "Down",
      "Left"
    ]
  },
  {
    id: 4,
    edges: [
      "B",
      "A",
      "A",
      "B"
    ],
    connections: [
      "Up",
      "Right"
    ]
  },
  {
    id: 5,
    edges: [
      "B",
      "B",
      "A",
      "A"
    ],
    connections: [
      "Up",
      "Left"
    ]
  },
  {
    id: 6,
    edges: [
      "A",
      "A",
      "A",
      "B"
    ],
    connections: [
      "Up",
      "Down",
      "Right"
    ]
  },
  {
    id: 7,
    edges: [
      "A",
      "B",
      "A",
      "A"
    ],
    connections: [
      "Up",
      "Down",
      "Left"
    ]
  },
  {
    id: 8,
    edges: [
      "B",
      "A",
      "A",
      "A"
    ],
    connections: [
      "Left",
      "Right",
      "Up"
    ]
  },
  {
    id: 9,
    edges: [
      "A",
      "A",
      "B",
      "A"
    ],
    connections: [
      "Left",
      "Right",
      "Down"
    ]
  },
  {
    id: 10,
    edges: [
      "A",
      "A",
      "A",
      "A"
    ],
    connections: [
      "Up",
      "Down",
      "Left",
      "Right"
    ]
  }
];

function createGrid(size) {
  return Core__Array.make(Math.imul(size, size), undefined).map(function () {
              return {
                      collapsed: false,
                      options: tiles
                    };
            });
}

function canConnect(tile1, dir1, tile2, dir2) {
  var match;
  switch (dir1) {
    case "Up" :
        if (dir2 === "Down") {
          var match$1 = tile1.edges;
          var match$2 = tile2.edges;
          match = [
            match$1[0],
            match$2[2]
          ];
        } else {
          match = [
            "A",
            "B"
          ];
        }
        break;
    case "Right" :
        if (dir2 === "Left") {
          var match$3 = tile1.edges;
          var match$4 = tile2.edges;
          match = [
            match$3[1],
            match$4[3]
          ];
        } else {
          match = [
            "A",
            "B"
          ];
        }
        break;
    case "Down" :
        if (dir2 === "Up") {
          var match$5 = tile1.edges;
          var match$6 = tile2.edges;
          match = [
            match$5[2],
            match$6[0]
          ];
        } else {
          match = [
            "A",
            "B"
          ];
        }
        break;
    case "Left" :
        if (dir2 === "Right") {
          var match$7 = tile1.edges;
          var match$8 = tile2.edges;
          match = [
            match$7[3],
            match$8[1]
          ];
        } else {
          match = [
            "A",
            "B"
          ];
        }
        break;
    
  }
  return match[0] === match[1];
}

function getValidOptions(grid, x, y, gridSize) {
  var index = Math.imul(y, gridSize) + x | 0;
  var cell = grid[index];
  if (cell !== undefined) {
    if (cell.collapsed) {
      return cell.options;
    } else {
      return cell.options.filter(function (tile) {
                  var validUp;
                  if (y > 0) {
                    var neighborIndex = Math.imul(y - 1 | 0, gridSize) + x | 0;
                    var neighbor = grid[neighborIndex];
                    validUp = neighbor !== undefined && neighbor.collapsed ? neighbor.options.some(function (nTile) {
                            return canConnect(tile, "Up", nTile, "Down");
                          }) : true;
                  } else {
                    validUp = true;
                  }
                  var validRight;
                  if (x < (gridSize - 1 | 0)) {
                    var neighborIndex$1 = Math.imul(y, gridSize) + (x + 1 | 0) | 0;
                    var neighbor$1 = grid[neighborIndex$1];
                    validRight = neighbor$1 !== undefined && neighbor$1.collapsed ? neighbor$1.options.some(function (nTile) {
                            return canConnect(tile, "Right", nTile, "Left");
                          }) : true;
                  } else {
                    validRight = true;
                  }
                  var validDown;
                  if (y < (gridSize - 1 | 0)) {
                    var neighborIndex$2 = Math.imul(y + 1 | 0, gridSize) + x | 0;
                    var neighbor$2 = grid[neighborIndex$2];
                    validDown = neighbor$2 !== undefined && neighbor$2.collapsed ? neighbor$2.options.some(function (nTile) {
                            return canConnect(tile, "Down", nTile, "Up");
                          }) : true;
                  } else {
                    validDown = true;
                  }
                  var validLeft;
                  if (x > 0) {
                    var neighborIndex$3 = Math.imul(y, gridSize) + (x - 1 | 0) | 0;
                    var neighbor$3 = grid[neighborIndex$3];
                    validLeft = neighbor$3 !== undefined && neighbor$3.collapsed ? neighbor$3.options.some(function (nTile) {
                            return canConnect(tile, "Left", nTile, "Right");
                          }) : true;
                  } else {
                    validLeft = true;
                  }
                  if (validUp && validRight && validDown) {
                    return validLeft;
                  } else {
                    return false;
                  }
                });
    }
  } else {
    return [];
  }
}

var wfcState = {
  contents: {
    grid: createGrid(8),
    gridSize: 8,
    cellSize: 0.0,
    collapsed: false,
    layers: Core__Array.make(64, 0)
  }
};

function regenerate() {
  var totalCells = Math.imul(state.contents.gridSize, state.contents.gridSize);
  wfcState.contents = {
    grid: createGrid(state.contents.gridSize),
    gridSize: state.contents.gridSize,
    cellSize: 0.0,
    collapsed: false,
    layers: Core__Array.make(totalCells, 0)
  };
  (((function() {
    const p = window.__currentP5Instance;
    if (p && !p.isLooping()) { p.loop(); }
  }))());
  console.log("Regenerating...");
}

function createControls() {
  var controlsDiv = document.getElementById("sketch-specific-controls");
  if (controlsDiv == null) {
    console.log("Sketch-specific controls container not found");
    return ;
  }
  controlsDiv.innerHTML = "";
  controlsDiv.className = "controls";
  var gridLabel = document.createElement("label");
  gridLabel.textContent = "Grid Size: ";
  gridLabel.setAttribute("for", "grid-size");
  controlsDiv.appendChild(gridLabel);
  var gridInput = document.createElement("input");
  gridInput.setAttribute("type", "number");
  gridInput.setAttribute("id", "grid-size");
  gridInput.value = "8";
  gridInput.setAttribute("min", "4");
  gridInput.setAttribute("max", "20");
  gridInput.setAttribute("step", "1");
  gridInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Int.fromString(gridInput.value, undefined), 20);
          var init = state.contents;
          state.contents = {
            pipeThickness: init.pipeThickness,
            gridSize: value,
            gapSize: init.gapSize,
            numLayers: init.numLayers,
            curviness: init.curviness,
            stretchiness: init.stretchiness
          };
          regenerate();
        }));
  controlsDiv.appendChild(gridInput);
  var thicknessLabel = document.createElement("label");
  thicknessLabel.textContent = " Thickness: ";
  thicknessLabel.setAttribute("for", "pipe-thickness");
  controlsDiv.appendChild(thicknessLabel);
  var thicknessInput = document.createElement("input");
  thicknessInput.setAttribute("type", "number");
  thicknessInput.setAttribute("id", "pipe-thickness");
  thicknessInput.value = "12";
  thicknessInput.setAttribute("min", "4");
  thicknessInput.setAttribute("max", "30");
  thicknessInput.setAttribute("step", "2");
  thicknessInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(thicknessInput.value), 8.0);
          var init = state.contents;
          state.contents = {
            pipeThickness: value,
            gridSize: init.gridSize,
            gapSize: init.gapSize,
            numLayers: init.numLayers,
            curviness: init.curviness,
            stretchiness: init.stretchiness
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(thicknessInput);
  var layersLabel = document.createElement("label");
  layersLabel.textContent = " Layers: ";
  layersLabel.setAttribute("for", "num-layers");
  controlsDiv.appendChild(layersLabel);
  var layersInput = document.createElement("input");
  layersInput.setAttribute("type", "number");
  layersInput.setAttribute("id", "num-layers");
  layersInput.value = "3";
  layersInput.setAttribute("min", "1");
  layersInput.setAttribute("max", "5");
  layersInput.setAttribute("step", "1");
  layersInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Int.fromString(layersInput.value, undefined), 3);
          var init = state.contents;
          state.contents = {
            pipeThickness: init.pipeThickness,
            gridSize: init.gridSize,
            gapSize: init.gapSize,
            numLayers: value,
            curviness: init.curviness,
            stretchiness: init.stretchiness
          };
          regenerate();
        }));
  controlsDiv.appendChild(layersInput);
  var gapLabel = document.createElement("label");
  gapLabel.textContent = " Gap: ";
  gapLabel.setAttribute("for", "gap-size");
  controlsDiv.appendChild(gapLabel);
  var gapInput = document.createElement("input");
  gapInput.setAttribute("type", "number");
  gapInput.setAttribute("id", "gap-size");
  gapInput.value = "6";
  gapInput.setAttribute("min", "0");
  gapInput.setAttribute("max", "20");
  gapInput.setAttribute("step", "1");
  gapInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(gapInput.value), 4.0);
          var init = state.contents;
          state.contents = {
            pipeThickness: init.pipeThickness,
            gridSize: init.gridSize,
            gapSize: value,
            numLayers: init.numLayers,
            curviness: init.curviness,
            stretchiness: init.stretchiness
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(gapInput);
  var curveLabel = document.createElement("label");
  curveLabel.textContent = " Curviness: ";
  curveLabel.setAttribute("for", "curviness");
  controlsDiv.appendChild(curveLabel);
  var curveInput = document.createElement("input");
  curveInput.setAttribute("type", "number");
  curveInput.setAttribute("id", "curviness");
  curveInput.value = "0.5";
  curveInput.setAttribute("min", "0");
  curveInput.setAttribute("max", "2");
  curveInput.setAttribute("step", "0.1");
  curveInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(curveInput.value), 0.3);
          var init = state.contents;
          state.contents = {
            pipeThickness: init.pipeThickness,
            gridSize: init.gridSize,
            gapSize: init.gapSize,
            numLayers: init.numLayers,
            curviness: value,
            stretchiness: init.stretchiness
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(curveInput);
  var stretchLabel = document.createElement("label");
  stretchLabel.textContent = " Stretchiness: ";
  stretchLabel.setAttribute("for", "stretchiness");
  controlsDiv.appendChild(stretchLabel);
  var stretchInput = document.createElement("input");
  stretchInput.setAttribute("type", "number");
  stretchInput.setAttribute("id", "stretchiness");
  stretchInput.value = "1.0";
  stretchInput.setAttribute("min", "0.5");
  stretchInput.setAttribute("max", "3.0");
  stretchInput.setAttribute("step", "0.1");
  stretchInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(stretchInput.value), 1.0);
          var init = state.contents;
          state.contents = {
            pipeThickness: init.pipeThickness,
            gridSize: init.gridSize,
            gapSize: init.gapSize,
            numLayers: init.numLayers,
            curviness: init.curviness,
            stretchiness: value
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(stretchInput);
  var regenButton = document.createElement("button");
  regenButton.textContent = "Regenerate";
  regenButton.setAttribute("id", "regenerate-btn");
  regenButton.addEventListener("click", (function () {
          regenerate();
        }));
  controlsDiv.appendChild(regenButton);
  console.log("WFC Pipes controls created");
}

function drawCurvedPipe(p, x1, y1, x2, y2, thickness, layer, gapSize, crossings, numLayers, curviness) {
  var layerShade = 250.0 - layer / numLayers * 200.0;
  var shade = layerShade | 0;
  p.noFill();
  p.stroke(shade, shade, shade);
  p.strokeWeight(thickness | 0);
  (((function(p) { p.strokeCap(p.ROUND); }))(p));
  var dx = x2 - x1;
  var dy = y2 - y1;
  var length = Math.sqrt(dx * dx + dy * dy);
  var perpX = - dy;
  var perpLen = Math.sqrt(perpX * perpX + dx * dx);
  var normPerpX = perpLen > 0.0 ? perpX / perpLen : 0.0;
  var normPerpY = perpLen > 0.0 ? dx / perpLen : 0.0;
  var midX = (x1 + x2) / 2.0;
  var midY = (y1 + y2) / 2.0;
  var randomOffset = ((Math.random() - 0.5) * 2.0);
  var offset = length * curviness * randomOffset;
  var cp1x = midX + normPerpX * offset;
  var cp1y = midY + normPerpY * offset;
  for(var i = 0; i <= 39; ++i){
    var t1 = i / 40;
    var t2 = (i + 1 | 0) / 40;
    var getPoint = function (t) {
      var mt = 1.0 - t;
      var mt2 = mt * mt;
      var t2 = t * t;
      var x = mt2 * x1 + 2.0 * mt * t * cp1x + t2 * x2;
      var y = mt2 * y1 + 2.0 * mt * t * cp1y + t2 * y2;
      return [
              x,
              y
            ];
    };
    var match = getPoint(t1);
    var sy1 = match[1];
    var sx1 = match[0];
    var match$1 = getPoint(t2);
    var sy2 = match$1[1];
    var sx2 = match$1[0];
    var smx = (sx1 + sx2) / 2.0;
    var smy = (sy1 + sy2) / 2.0;
    var crossingInfo = Core__Array.reduce(crossings, undefined, (function(smx,smy){
        return function (acc, param) {
          var cy = param[1];
          var cx = param[0];
          var dist = Math.sqrt((smx - cx) * (smx - cx) + (smy - cy) * (smy - cy));
          if (dist < gapSize * 3.0) {
            return [
                    param[2],
                    dist
                  ];
          } else {
            return acc;
          }
        }
        }(smx,smy)));
    if (crossingInfo !== undefined) {
      var clayer = crossingInfo[0];
      if (clayer > layer) {
        
      } else if (clayer < layer) {
        p.stroke(255);
        p.strokeWeight(thickness + 4.0 | 0);
        p.line(sx1, sy1, sx2, sy2);
        p.stroke(shade, shade, shade);
        p.strokeWeight(thickness | 0);
        p.line(sx1, sy1, sx2, sy2);
      } else {
        p.line(sx1, sy1, sx2, sy2);
      }
    } else {
      p.line(sx1, sy1, sx2, sy2);
    }
  }
  var jointShade = Math.min(layerShade + 30.0, 255.0) | 0;
  p.fill(jointShade, jointShade, jointShade);
  p.stroke(shade, shade, shade);
  p.strokeWeight(2);
  p.circle(x1, y1, thickness);
  p.circle(x2, y2, thickness);
}

function draw(p, paperSize) {
  var gridSize = state.contents.gridSize;
  var pipeThickness = state.contents.pipeThickness;
  var gapSize = state.contents.gapSize;
  var numLayers = state.contents.numLayers;
  var curviness = state.contents.curviness;
  var stretchiness = state.contents.stretchiness;
  var minDimension = Math.min(paperSize.width, paperSize.height);
  var cellSize = minDimension / gridSize;
  if (wfcState.contents.cellSize !== cellSize || wfcState.contents.gridSize !== gridSize) {
    var totalCells = Math.imul(gridSize, gridSize);
    var layers = Core__Array.make(totalCells, 0).map(function (param, i) {
          return (Math.floor(Math.random() * numLayers));
        });
    wfcState.contents = {
      grid: createGrid(gridSize),
      gridSize: gridSize,
      cellSize: cellSize,
      collapsed: false,
      layers: layers
    };
  }
  if (wfcState.contents.collapsed) {
    if (wfcState.contents.collapsed) {
      (((function(p) { p.noLoop(); }))(p));
    }
    
  } else {
    var minEntropy = {
      contents: 999999
    };
    var minIndex = {
      contents: -1
    };
    wfcState.contents.grid.forEach(function (cell, i) {
          if (!(!cell.collapsed && cell.options.length > 0)) {
            return ;
          }
          var entropy = cell.options.length;
          if (entropy < minEntropy.contents) {
            minEntropy.contents = entropy;
            minIndex.contents = i;
            return ;
          }
          
        });
    if (minIndex.contents >= 0) {
      var cell = wfcState.contents.grid[minIndex.contents];
      if (cell !== undefined) {
        var x = Caml_int32.mod_(minIndex.contents, gridSize);
        var y = Caml_int32.div(minIndex.contents, gridSize);
        var validOptions = getValidOptions(wfcState.contents.grid, x, y, gridSize);
        if (validOptions.length > 0) {
          var randomIndex = (Math.floor(Math.random() * validOptions.length));
          var tile = validOptions[randomIndex];
          if (tile !== undefined) {
            cell.options = [tile];
            cell.collapsed = true;
          } else {
            cell.options = [Core__Option.getOr(tiles[0], {
                    id: 0,
                    edges: [
                      "A",
                      "B",
                      "A",
                      "B"
                    ],
                    connections: [
                      "Up",
                      "Down"
                    ]
                  })];
            cell.collapsed = true;
          }
        } else {
          cell.options = [Core__Option.getOr(tiles[0], {
                  id: 0,
                  edges: [
                    "A",
                    "B",
                    "A",
                    "B"
                  ],
                  connections: [
                    "Up",
                    "Down"
                  ]
                })];
          cell.collapsed = true;
        }
      }
      
    } else {
      var init = wfcState.contents;
      wfcState.contents = {
        grid: init.grid,
        gridSize: init.gridSize,
        cellSize: init.cellSize,
        collapsed: true,
        layers: init.layers
      };
      (((function(p) { p.noLoop(); }))(p));
      console.log("WFC generation complete - drawing stopped");
    }
  }
  var totalWidth = gridSize * cellSize;
  var totalHeight = gridSize * cellSize;
  var offsetX = (paperSize.width - totalWidth) / 2.0;
  var offsetY = (paperSize.height - totalHeight) / 2.0;
  var crossings = [];
  wfcState.contents.grid.forEach(function (cell, i) {
        if (!(cell.collapsed && cell.options.length > 0)) {
          return ;
        }
        var x = Caml_int32.mod_(i, gridSize);
        var y = Caml_int32.div(i, gridSize);
        var cx = offsetX + x * cellSize + cellSize / 2.0;
        var cy = offsetY + y * cellSize + cellSize / 2.0;
        var layer = Core__Option.getOr(wfcState.contents.layers[i], 0);
        (((function(arr, x, y, l) { arr.push([x, y, l]); }))(crossings, cx, cy, layer));
      });
  for(var layer = 0; layer < numLayers; ++layer){
    wfcState.contents.grid.forEach((function(layer){
        return function (cell, i) {
          var cellLayer = Core__Option.getOr(wfcState.contents.layers[i], 0);
          if (!(cellLayer === layer && cell.collapsed && cell.options.length > 0)) {
            return ;
          }
          var x = Caml_int32.mod_(i, gridSize);
          var y = Caml_int32.div(i, gridSize);
          var cx = offsetX + x * cellSize + cellSize / 2.0;
          var cy = offsetY + y * cellSize + cellSize / 2.0;
          var tile = cell.options[0];
          if (tile !== undefined) {
            tile.connections.forEach(function (dir) {
                  var stretch = cellSize / 2.0 * stretchiness;
                  var match;
                  switch (dir) {
                    case "Up" :
                        match = [
                          cx,
                          cy - stretch
                        ];
                        break;
                    case "Right" :
                        match = [
                          cx + stretch,
                          cy
                        ];
                        break;
                    case "Down" :
                        match = [
                          cx,
                          cy + stretch
                        ];
                        break;
                    case "Left" :
                        match = [
                          cx - stretch,
                          cy
                        ];
                        break;
                    
                  }
                  drawCurvedPipe(p, cx, cy, match[0], match[1], pipeThickness, layer, gapSize, crossings, numLayers, curviness);
                });
            return ;
          }
          
        }
        }(layer)));
  }
}

function createSketch() {
  createControls();
  return PlotterFrame.createPlotterSketch(draw)();
}

export {
  state ,
  tiles ,
  createGrid ,
  canConnect ,
  getValidOptions ,
  wfcState ,
  regenerate ,
  createControls ,
  drawCurvedPipe ,
  draw ,
  createSketch ,
}
/* wfcState Not a pure module */
