// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Float from "@rescript/core/src/Core__Float.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as PlotterFrame from "./PlotterFrame.res.mjs";

var state = {
  contents: {
    shapeType: 4,
    shapeSize: 30.0,
    rotation: 1.0
  }
};

function createControls() {
  var controlsDiv = document.getElementById("sketch-specific-controls");
  if (controlsDiv == null) {
    console.log("Sketch-specific controls container not found");
    return ;
  }
  controlsDiv.innerHTML = "";
  controlsDiv.className = "controls";
  var shapeLabel = document.createElement("label");
  shapeLabel.textContent = "Shape: ";
  shapeLabel.setAttribute("for", "shape-type");
  controlsDiv.appendChild(shapeLabel);
  var shapeSelect = document.createElement("select");
  shapeSelect.setAttribute("id", "shape-type");
  var shapes = [
    [
      "square",
      "Square",
      4
    ],
    [
      "circle",
      "Circle",
      0
    ],
    [
      "triangle",
      "Triangle",
      3
    ],
    [
      "pentagon",
      "Pentagon",
      5
    ],
    [
      "hexagon",
      "Hexagon",
      6
    ],
    [
      "octagon",
      "Octagon",
      8
    ]
  ];
  shapes.forEach(function (param) {
        var option = document.createElement("option");
        option.value = param[0];
        option.textContent = param[1];
        shapeSelect.appendChild(option);
      });
  shapeSelect.addEventListener("change", (function () {
          var value = shapeSelect.value;
          var sides = Core__Option.getOr(Core__Option.map(shapes.find(function (param) {
                        return param[0] === value;
                      }), (function (param) {
                      return param[2];
                    })), 4);
          var init = state.contents;
          state.contents = {
            shapeType: sides,
            shapeSize: init.shapeSize,
            rotation: init.rotation
          };
        }));
  controlsDiv.appendChild(shapeSelect);
  var sizeLabel = document.createElement("label");
  sizeLabel.textContent = " Size (px): ";
  sizeLabel.setAttribute("for", "shape-size");
  controlsDiv.appendChild(sizeLabel);
  var sizeInput = document.createElement("input");
  sizeInput.setAttribute("type", "number");
  sizeInput.setAttribute("id", "shape-size");
  sizeInput.value = "30";
  sizeInput.setAttribute("min", "5");
  sizeInput.setAttribute("max", "200");
  sizeInput.setAttribute("step", "1");
  sizeInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(sizeInput.value), 30.0);
          var init = state.contents;
          state.contents = {
            shapeType: init.shapeType,
            shapeSize: value,
            rotation: init.rotation
          };
        }));
  controlsDiv.appendChild(sizeInput);
  var rotationLabel = document.createElement("label");
  rotationLabel.textContent = " Rotation: ";
  rotationLabel.setAttribute("for", "rotation-multiplier");
  controlsDiv.appendChild(rotationLabel);
  var rotationInput = document.createElement("input");
  rotationInput.setAttribute("type", "number");
  rotationInput.setAttribute("id", "rotation-multiplier");
  rotationInput.value = "1.0";
  rotationInput.setAttribute("min", "0");
  rotationInput.setAttribute("max", "10");
  rotationInput.setAttribute("step", "0.1");
  rotationInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(rotationInput.value), 1.0);
          var init = state.contents;
          state.contents = {
            shapeType: init.shapeType,
            shapeSize: init.shapeSize,
            rotation: value
          };
        }));
  controlsDiv.appendChild(rotationInput);
  console.log("Grid controls created");
}

function drawPolygon(p, x, y, radius, sides, rotation) {
  p.noFill();
  p.stroke(0);
  p.strokeWeight(1);
  if (sides === 0) {
    p.circle(x, y, radius * 2.0);
    return ;
  }
  var angle = 2.0 * Math.PI / sides;
  var vertices = Core__Array.make(sides, [
          0.0,
          0.0
        ]).map(function (param, i) {
        var a = i * angle - Math.PI / 2.0 + rotation;
        var vx = x + Math.cos(a) * radius;
        var vy = y + Math.sin(a) * radius;
        return [
                vx,
                vy
              ];
      });
  (((function(p) { p.beginShape(); }))(p));
  vertices.forEach(function (param) {
        (((function(p, vx, vy) { p.vertex(vx, vy); }))(p, param[0], param[1]));
      });
  (((function(p) { p.endShape(p.CLOSE); }))(p));
}

function draw(p, paperSize) {
  var sides = state.contents.shapeType;
  var shapeSize = state.contents.shapeSize;
  var rotationMultiplier = state.contents.rotation;
  var availableWidth = paperSize.width - 20.0 * 2.0;
  var availableHeight = paperSize.height - 20.0 * 2.0;
  var numCols = availableWidth / shapeSize | 0;
  var numRows = availableHeight / shapeSize | 0;
  var actualWidth = numCols * shapeSize;
  var actualHeight = numRows * shapeSize;
  var startX = (paperSize.width - actualWidth) / 2.0;
  var startY = (paperSize.height - actualHeight) / 2.0;
  var totalCells = Math.imul(numCols, numRows);
  for(var row = 0; row < numRows; ++row){
    for(var col = 0; col < numCols; ++col){
      var x = startX + col * shapeSize + shapeSize / 2.0;
      var y = startY + row * shapeSize + shapeSize / 2.0;
      var radius = shapeSize / 2.0;
      var cellIndex = Math.imul(row, numCols) + col | 0;
      var progress = cellIndex / totalCells;
      var rotation = progress * rotationMultiplier * 2.0 * Math.PI;
      drawPolygon(p, x, y, radius, sides, rotation);
    }
  }
}

function createSketch() {
  createControls();
  return PlotterFrame.createPlotterSketch(draw)();
}

export {
  state ,
  createControls ,
  drawPolygon ,
  draw ,
  createSketch ,
}
/* PlotterFrame Not a pure module */
