// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Float from "@rescript/core/src/Core__Float.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as PlotterFrame from "./PlotterFrame.res.mjs";

var state = {
  contents: {
    gridSize: 10,
    grainDensity: 8,
    waviness: 0.3,
    lineWeight: 1.0,
    knotFrequency: 0.05
  }
};

var tiles = [
  {
    id: 0,
    edges: [
      "Vertical",
      "Horizontal",
      "Vertical",
      "Horizontal"
    ],
    grainDirection: "Up",
    hasKnot: false
  },
  {
    id: 1,
    edges: [
      "Vertical",
      "Horizontal",
      "Vertical",
      "Horizontal"
    ],
    grainDirection: "Down",
    hasKnot: false
  },
  {
    id: 2,
    edges: [
      "Vertical",
      "Horizontal",
      "Vertical",
      "Horizontal"
    ],
    grainDirection: "Up",
    hasKnot: true
  }
];

function createGrid(size) {
  return Core__Array.make(Math.imul(size, size), undefined).map(function () {
              return {
                      collapsed: false,
                      options: tiles
                    };
            });
}

function canConnect(tile1, dir1, tile2, dir2) {
  var match;
  switch (dir1) {
    case "Up" :
        if (dir2 === "Down") {
          var match$1 = tile1.edges;
          var match$2 = tile2.edges;
          match = [
            match$1[0],
            match$2[2]
          ];
        } else {
          match = [
            "Horizontal",
            "Vertical"
          ];
        }
        break;
    case "Right" :
        if (dir2 === "Left") {
          var match$3 = tile1.edges;
          var match$4 = tile2.edges;
          match = [
            match$3[1],
            match$4[3]
          ];
        } else {
          match = [
            "Horizontal",
            "Vertical"
          ];
        }
        break;
    case "Down" :
        if (dir2 === "Up") {
          var match$5 = tile1.edges;
          var match$6 = tile2.edges;
          match = [
            match$5[2],
            match$6[0]
          ];
        } else {
          match = [
            "Horizontal",
            "Vertical"
          ];
        }
        break;
    case "Left" :
        if (dir2 === "Right") {
          var match$7 = tile1.edges;
          var match$8 = tile2.edges;
          match = [
            match$7[3],
            match$8[1]
          ];
        } else {
          match = [
            "Horizontal",
            "Vertical"
          ];
        }
        break;
    
  }
  return match[0] === match[1];
}

function getValidOptions(grid, x, y, gridSize) {
  var index = Math.imul(y, gridSize) + x | 0;
  var cell = grid[index];
  if (cell !== undefined) {
    if (cell.collapsed) {
      return cell.options;
    } else {
      return cell.options.filter(function (tile) {
                  var validUp;
                  if (y > 0) {
                    var neighborIndex = Math.imul(y - 1 | 0, gridSize) + x | 0;
                    var neighbor = grid[neighborIndex];
                    validUp = neighbor !== undefined && neighbor.collapsed ? neighbor.options.some(function (nTile) {
                            return canConnect(tile, "Up", nTile, "Down");
                          }) : true;
                  } else {
                    validUp = true;
                  }
                  var validRight;
                  if (x < (gridSize - 1 | 0)) {
                    var neighborIndex$1 = Math.imul(y, gridSize) + (x + 1 | 0) | 0;
                    var neighbor$1 = grid[neighborIndex$1];
                    validRight = neighbor$1 !== undefined && neighbor$1.collapsed ? neighbor$1.options.some(function (nTile) {
                            return canConnect(tile, "Right", nTile, "Left");
                          }) : true;
                  } else {
                    validRight = true;
                  }
                  var validDown;
                  if (y < (gridSize - 1 | 0)) {
                    var neighborIndex$2 = Math.imul(y + 1 | 0, gridSize) + x | 0;
                    var neighbor$2 = grid[neighborIndex$2];
                    validDown = neighbor$2 !== undefined && neighbor$2.collapsed ? neighbor$2.options.some(function (nTile) {
                            return canConnect(tile, "Down", nTile, "Up");
                          }) : true;
                  } else {
                    validDown = true;
                  }
                  var validLeft;
                  if (x > 0) {
                    var neighborIndex$3 = Math.imul(y, gridSize) + (x - 1 | 0) | 0;
                    var neighbor$3 = grid[neighborIndex$3];
                    validLeft = neighbor$3 !== undefined && neighbor$3.collapsed ? neighbor$3.options.some(function (nTile) {
                            return canConnect(tile, "Left", nTile, "Right");
                          }) : true;
                  } else {
                    validLeft = true;
                  }
                  if (validUp && validRight && validDown) {
                    return validLeft;
                  } else {
                    return false;
                  }
                });
    }
  } else {
    return [];
  }
}

var wfcState = {
  contents: {
    grid: createGrid(10),
    gridSize: 10,
    cellSize: 0.0,
    collapsed: false
  }
};

function regenerate() {
  wfcState.contents = {
    grid: createGrid(state.contents.gridSize),
    gridSize: state.contents.gridSize,
    cellSize: 0.0,
    collapsed: false
  };
  (((function() {
    const p = window.__currentP5Instance;
    if (p && !p.isLooping()) { p.loop(); }
  }))());
  console.log("Regenerating wood grain...");
}

function createControls() {
  var controlsDiv = document.getElementById("sketch-specific-controls");
  if (controlsDiv == null) {
    console.log("Sketch-specific controls container not found");
    return ;
  }
  controlsDiv.innerHTML = "";
  controlsDiv.className = "controls";
  var gridLabel = document.createElement("label");
  gridLabel.textContent = "Grid Size: ";
  gridLabel.setAttribute("for", "grid-size");
  controlsDiv.appendChild(gridLabel);
  var gridInput = document.createElement("input");
  gridInput.setAttribute("type", "number");
  gridInput.setAttribute("id", "grid-size");
  gridInput.value = "10";
  gridInput.setAttribute("min", "4");
  gridInput.setAttribute("max", "25");
  gridInput.setAttribute("step", "1");
  gridInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Int.fromString(gridInput.value, undefined), 10);
          var init = state.contents;
          state.contents = {
            gridSize: value,
            grainDensity: init.grainDensity,
            waviness: init.waviness,
            lineWeight: init.lineWeight,
            knotFrequency: init.knotFrequency
          };
          regenerate();
        }));
  controlsDiv.appendChild(gridInput);
  var densityLabel = document.createElement("label");
  densityLabel.textContent = " Grain Lines: ";
  densityLabel.setAttribute("for", "grain-density");
  controlsDiv.appendChild(densityLabel);
  var densityInput = document.createElement("input");
  densityInput.setAttribute("type", "number");
  densityInput.setAttribute("id", "grain-density");
  densityInput.value = "8";
  densityInput.setAttribute("min", "3");
  densityInput.setAttribute("max", "20");
  densityInput.setAttribute("step", "1");
  densityInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Int.fromString(densityInput.value, undefined), 8);
          var init = state.contents;
          state.contents = {
            gridSize: init.gridSize,
            grainDensity: value,
            waviness: init.waviness,
            lineWeight: init.lineWeight,
            knotFrequency: init.knotFrequency
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(densityInput);
  var wavinessLabel = document.createElement("label");
  wavinessLabel.textContent = " Waviness: ";
  wavinessLabel.setAttribute("for", "waviness");
  controlsDiv.appendChild(wavinessLabel);
  var wavinessInput = document.createElement("input");
  wavinessInput.setAttribute("type", "number");
  wavinessInput.setAttribute("id", "waviness");
  wavinessInput.value = "0.3";
  wavinessInput.setAttribute("min", "0");
  wavinessInput.setAttribute("max", "1.5");
  wavinessInput.setAttribute("step", "0.1");
  wavinessInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(wavinessInput.value), 0.3);
          var init = state.contents;
          state.contents = {
            gridSize: init.gridSize,
            grainDensity: init.grainDensity,
            waviness: value,
            lineWeight: init.lineWeight,
            knotFrequency: init.knotFrequency
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(wavinessInput);
  var weightLabel = document.createElement("label");
  weightLabel.textContent = " Line Weight: ";
  weightLabel.setAttribute("for", "line-weight");
  controlsDiv.appendChild(weightLabel);
  var weightInput = document.createElement("input");
  weightInput.setAttribute("type", "number");
  weightInput.setAttribute("id", "line-weight");
  weightInput.value = "1.0";
  weightInput.setAttribute("min", "0.5");
  weightInput.setAttribute("max", "3.0");
  weightInput.setAttribute("step", "0.5");
  weightInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(weightInput.value), 1.0);
          var init = state.contents;
          state.contents = {
            gridSize: init.gridSize,
            grainDensity: init.grainDensity,
            waviness: init.waviness,
            lineWeight: value,
            knotFrequency: init.knotFrequency
          };
          (((function() {
          const p = window.__currentP5Instance;
          if (p) { p.redraw(); }
        }))());
        }));
  controlsDiv.appendChild(weightInput);
  var knotLabel = document.createElement("label");
  knotLabel.textContent = " Knots: ";
  knotLabel.setAttribute("for", "knot-freq");
  controlsDiv.appendChild(knotLabel);
  var knotInput = document.createElement("input");
  knotInput.setAttribute("type", "number");
  knotInput.setAttribute("id", "knot-freq");
  knotInput.value = "0.05";
  knotInput.setAttribute("min", "0");
  knotInput.setAttribute("max", "0.3");
  knotInput.setAttribute("step", "0.05");
  knotInput.addEventListener("input", (function () {
          var value = Core__Option.getOr(Core__Float.fromString(knotInput.value), 0.05);
          var init = state.contents;
          state.contents = {
            gridSize: init.gridSize,
            grainDensity: init.grainDensity,
            waviness: init.waviness,
            lineWeight: init.lineWeight,
            knotFrequency: value
          };
          regenerate();
        }));
  controlsDiv.appendChild(knotInput);
  var regenButton = document.createElement("button");
  regenButton.textContent = "Regenerate";
  regenButton.setAttribute("id", "regenerate-btn");
  regenButton.addEventListener("click", (function () {
          regenerate();
        }));
  controlsDiv.appendChild(regenButton);
  console.log("Wood grain controls created");
}

function drawWoodGrain(p, cx, cy, cellSize, tile, density, waviness, weight) {
  p.stroke(0);
  p.strokeWeight(weight | 0);
  p.noFill();
  if (tile.hasKnot) {
    var spacing = cellSize / (density + 1 | 0);
    for(var i = 1; i <= density; ++i){
      var offset = i * spacing - cellSize / 2.0;
      var randomOffset = ((Math.random() - 0.5)) * spacing * 0.5;
      var lineOffset = offset + randomOffset;
      var freqVariation = 1.5 + (Math.random()) * 1.5;
      var phaseOffset = (Math.random()) * Math.PI * 2.0;
      (((function(p) { p.beginShape(); }))(p));
      for(var j = 0; j <= 25; ++j){
        var t = j / 25;
        var y = cy - cellSize / 2.0 + t * cellSize;
        var distFromCenter = Math.abs((cy - y) / cellSize);
        var knotInfluence = 1.0 - distFromCenter * 2.0;
        var knotPush;
        if (knotInfluence > 0.0) {
          var pushAmount = knotInfluence * cellSize * 0.15;
          knotPush = lineOffset > 0.0 ? pushAmount : - pushAmount;
        } else {
          knotPush = 0.0;
        }
        var wave1 = Math.sin(t * Math.PI * freqVariation + phaseOffset) * waviness * cellSize * 0.08;
        var wave2 = Math.sin(t * Math.PI * 5.0 + phaseOffset * 2.0) * waviness * cellSize * 0.03;
        var noise = ((Math.random() - 0.5)) * waviness * 0.5;
        var x = cx + lineOffset + wave1 + wave2 + noise + knotPush;
        (((function(p, x, y) { p.vertex(x, y); }))(p, x, y));
      }
      (((function(p) { p.endShape(); }))(p));
    }
    var numRings = Math.max(3, density / 3 | 0);
    var knotOffsetX = ((Math.random() - 0.5)) * cellSize * 0.15;
    var knotOffsetY = ((Math.random() - 0.5)) * cellSize * 0.15;
    p.strokeWeight(weight * 0.5 | 0);
    for(var i$1 = 1; i$1 <= numRings; ++i$1){
      var baseRadius = i$1 / numRings * cellSize * 0.25;
      (((function(p) { p.beginShape(); }))(p));
      for(var j$1 = 0; j$1 <= 40; ++j$1){
        var angle = j$1 / 40 * 2.0 * Math.PI;
        var noiseAmount = Math.sin(angle * 4.0 + i$1) * waviness * 1.5;
        var r = baseRadius + noiseAmount;
        var x$1 = cx + knotOffsetX + Math.cos(angle) * r;
        var y$1 = cy + knotOffsetY + Math.sin(angle) * r * 0.8;
        (((function(p, x, y) { p.vertex(x, y); }))(p, x$1, y$1));
      }
      (((function(p) { p.endShape(p.CLOSE); }))(p));
    }
    p.strokeWeight(weight | 0);
    return ;
  }
  var spacing$1 = cellSize / (density + 1 | 0);
  for(var i$2 = 1; i$2 <= density; ++i$2){
    var offset$1 = i$2 * spacing$1 - cellSize / 2.0;
    var randomOffset$1 = ((Math.random() - 0.5)) * spacing$1 * 0.5;
    var lineOffset$1 = offset$1 + randomOffset$1;
    var freqVariation$1 = 1.5 + (Math.random()) * 1.5;
    var phaseOffset$1 = (Math.random()) * Math.PI * 2.0;
    (((function(p) { p.beginShape(); }))(p));
    var match = tile.grainDirection;
    var match$1;
    var exit = 0;
    switch (match) {
      case "Up" :
          match$1 = [
            cy + cellSize / 2.0,
            cy - cellSize / 2.0
          ];
          break;
      case "Down" :
          match$1 = [
            cy - cellSize / 2.0,
            cy + cellSize / 2.0
          ];
          break;
      case "Right" :
      case "Left" :
          exit = 1;
          break;
      
    }
    if (exit === 1) {
      match$1 = [
        cy - cellSize / 2.0,
        cy + cellSize / 2.0
      ];
    }
    var endY = match$1[1];
    var startY = match$1[0];
    for(var j$2 = 0; j$2 <= 25; ++j$2){
      var t$1 = j$2 / 25;
      var y$2 = startY + t$1 * (endY - startY);
      var wave1$1 = Math.sin(t$1 * Math.PI * freqVariation$1 + phaseOffset$1) * waviness * cellSize * 0.08;
      var wave2$1 = Math.sin(t$1 * Math.PI * 5.0 + phaseOffset$1 * 2.0) * waviness * cellSize * 0.03;
      var noise$1 = ((Math.random() - 0.5)) * waviness * 0.5;
      var x$2 = cx + lineOffset$1 + wave1$1 + wave2$1 + noise$1;
      (((function(p, x, y) { p.vertex(x, y); }))(p, x$2, y$2));
    }
    (((function(p) { p.endShape(); }))(p));
  }
}

function draw(p, paperSize) {
  var gridSize = state.contents.gridSize;
  var grainDensity = state.contents.grainDensity;
  var waviness = state.contents.waviness;
  var lineWeight = state.contents.lineWeight;
  var knotFrequency = state.contents.knotFrequency;
  var minDimension = Math.min(paperSize.width, paperSize.height);
  var cellSize = minDimension / gridSize;
  if (wfcState.contents.cellSize !== cellSize || wfcState.contents.gridSize !== gridSize) {
    wfcState.contents = {
      grid: createGrid(gridSize),
      gridSize: gridSize,
      cellSize: cellSize,
      collapsed: false
    };
  }
  if (!wfcState.contents.collapsed) {
    var minEntropy = {
      contents: 999999
    };
    var minIndex = {
      contents: -1
    };
    wfcState.contents.grid.forEach(function (cell, i) {
          if (!(!cell.collapsed && cell.options.length > 0)) {
            return ;
          }
          var entropy = cell.options.length;
          if (entropy < minEntropy.contents) {
            minEntropy.contents = entropy;
            minIndex.contents = i;
            return ;
          }
          
        });
    if (minIndex.contents >= 0) {
      var cell = wfcState.contents.grid[minIndex.contents];
      if (cell !== undefined) {
        var x = Caml_int32.mod_(minIndex.contents, gridSize);
        var y = Caml_int32.div(minIndex.contents, gridSize);
        var validOptions = getValidOptions(wfcState.contents.grid, x, y, gridSize);
        if (validOptions.length > 0) {
          var shouldHaveKnot = (Math.random()) < knotFrequency;
          var filteredOptions;
          if (shouldHaveKnot) {
            var knotOptions = validOptions.filter(function (t) {
                  return t.hasKnot;
                });
            filteredOptions = knotOptions.length > 0 ? knotOptions : validOptions;
          } else {
            filteredOptions = validOptions.filter(function (t) {
                  return !t.hasKnot;
                });
          }
          var optionsToUse = filteredOptions.length > 0 ? filteredOptions : validOptions;
          var randomIndex = (Math.floor(Math.random() * optionsToUse.length));
          var tile = optionsToUse[randomIndex];
          if (tile !== undefined) {
            cell.options = [tile];
            cell.collapsed = true;
          } else {
            cell.options = [Core__Option.getOr(tiles[0], {
                    id: 0,
                    edges: [
                      "Horizontal",
                      "Vertical",
                      "Horizontal",
                      "Vertical"
                    ],
                    grainDirection: "Right",
                    hasKnot: false
                  })];
            cell.collapsed = true;
          }
        } else {
          cell.options = [Core__Option.getOr(tiles[0], {
                  id: 0,
                  edges: [
                    "Horizontal",
                    "Vertical",
                    "Horizontal",
                    "Vertical"
                  ],
                  grainDirection: "Right",
                  hasKnot: false
                })];
          cell.collapsed = true;
        }
      }
      
    } else {
      var init = wfcState.contents;
      wfcState.contents = {
        grid: init.grid,
        gridSize: init.gridSize,
        cellSize: init.cellSize,
        collapsed: true
      };
      (((function(p) { p.noLoop(); }))(p));
      console.log("Wood grain generation complete");
    }
  }
  var totalWidth = gridSize * cellSize;
  var totalHeight = gridSize * cellSize;
  var offsetX = (paperSize.width - totalWidth) / 2.0;
  var offsetY = (paperSize.height - totalHeight) / 2.0;
  wfcState.contents.grid.forEach(function (cell, i) {
        if (!(cell.collapsed && cell.options.length > 0)) {
          return ;
        }
        var x = Caml_int32.mod_(i, gridSize);
        var y = Caml_int32.div(i, gridSize);
        var cx = offsetX + x * cellSize + cellSize / 2.0;
        var cy = offsetY + y * cellSize + cellSize / 2.0;
        var tile = cell.options[0];
        if (tile !== undefined) {
          return drawWoodGrain(p, cx, cy, cellSize, tile, grainDensity, waviness, lineWeight);
        }
        
      });
}

function createSketch() {
  createControls();
  return PlotterFrame.createPlotterSketch(draw)();
}

export {
  state ,
  tiles ,
  createGrid ,
  canConnect ,
  getValidOptions ,
  wfcState ,
  regenerate ,
  createControls ,
  drawWoodGrain ,
  draw ,
  createSketch ,
}
/* wfcState Not a pure module */
