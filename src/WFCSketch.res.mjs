// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

var tileColors = [
  [
    240,
    240,
    240
  ],
  [
    100,
    150,
    255
  ],
  [
    255,
    100,
    100
  ],
  [
    100,
    255,
    150
  ]
];

var adjacencyRules = [
  [
    [
      0,
      1,
      2,
      3
    ],
    [
      0,
      1,
      2,
      3
    ],
    [
      0,
      1,
      2,
      3
    ],
    [
      0,
      1,
      2,
      3
    ]
  ],
  [
    [
      0,
      1,
      3
    ],
    [
      1,
      3
    ],
    [
      0,
      1,
      3
    ],
    [
      1,
      3
    ]
  ],
  [
    [
      2,
      3
    ],
    [
      0,
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      0,
      2,
      3
    ]
  ],
  [
    [
      2,
      3
    ],
    [
      1,
      3
    ],
    [
      2,
      3
    ],
    [
      1,
      3
    ]
  ]
];

function createGrid(gridSize) {
  return Core__Array.make(gridSize, undefined).map(function () {
              return Core__Array.make(gridSize, undefined).map(function () {
                          return {
                                  index: -1,
                                  options: [
                                    0,
                                    1,
                                    2,
                                    3
                                  ]
                                };
                        });
            });
}

function getMinEntropyTile(grid) {
  var minEntropy = {
    contents: 999
  };
  var minPos = {
    contents: undefined
  };
  grid.forEach(function (row, y) {
        row.forEach(function (tile, x) {
              if (!(tile.index === -1 && tile.options.length > 0)) {
                return ;
              }
              var entropy = tile.options.length;
              if (entropy < minEntropy.contents) {
                minEntropy.contents = entropy;
                minPos.contents = [
                  x,
                  y
                ];
                return ;
              }
              
            });
      });
  return minPos.contents;
}

function collapseTile(tile, p) {
  if (tile.options.length === 0) {
    return tile;
  }
  var randomIndex = p.random(tile.options.length) | 0;
  var chosenOption = Core__Option.getOr(tile.options[randomIndex], 0);
  return {
          index: chosenOption,
          options: [chosenOption]
        };
}

function propagateConstraints(grid, x, y) {
  var newGrid = grid.map(function (row) {
        return row.map(function (tile) {
                    return tile;
                  });
      });
  var gridSize = grid.length;
  var centerTile = Core__Option.flatMap(grid[y], (function (row) {
          return row[x];
        }));
  if (centerTile === undefined) {
    return newGrid;
  }
  if (centerTile.index === -1) {
    return newGrid;
  }
  var tileIndex = centerTile.index;
  var rules = Core__Option.getOr(adjacencyRules[tileIndex], [
        [0],
        [0],
        [0],
        [0]
      ]);
  if (y > 0) {
    Core__Option.map(newGrid[y - 1 | 0], (function (row) {
            var neighbor = Core__Option.getOr(row[x], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[0], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  if (x < (gridSize - 1 | 0)) {
    Core__Option.map(newGrid[y], (function (row) {
            var neighbor = Core__Option.getOr(row[x + 1 | 0], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x + 1 | 0] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[1], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  if (y < (gridSize - 1 | 0)) {
    Core__Option.map(newGrid[y + 1 | 0], (function (row) {
            var neighbor = Core__Option.getOr(row[x], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[2], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  if (x > 0) {
    Core__Option.map(newGrid[y], (function (row) {
            var neighbor = Core__Option.getOr(row[x - 1 | 0], {
                  index: -1,
                  options: []
                });
            if (neighbor.index === -1) {
              row[x - 1 | 0] = {
                index: neighbor.index,
                options: neighbor.options.filter(function (opt) {
                      return Core__Option.getOr(rules[3], []).includes(opt);
                    })
              };
              return ;
            }
            
          }));
  }
  return newGrid;
}

function drawTile(p, tile, x, y, tileSize) {
  var xPos = Math.imul(x, tileSize);
  var yPos = Math.imul(y, tileSize);
  var size = tileSize;
  if (tile.index === -1) {
    var entropy = tile.options.length;
    var grayValue = 200 - Math.imul(entropy, 30) | 0;
    p.fill(grayValue);
    p.rect(xPos, yPos, size, size);
  } else {
    var color = Core__Option.getOr(tileColors[tile.index], [
          255,
          255,
          255
        ]);
    p.fill(color[0], color[1], color[2]);
    p.rect(xPos, yPos, size, size);
    p.stroke(0);
    p.strokeWeight(2);
    var match = tile.index;
    switch (match) {
      case 1 :
          p.line(xPos, yPos + size / 2.0, xPos + size, yPos + size / 2.0);
          break;
      case 2 :
          p.line(xPos + size / 2.0, yPos, xPos + size / 2.0, yPos + size);
          break;
      case 3 :
          p.line(xPos, yPos + size / 2.0, xPos + size, yPos + size / 2.0);
          p.line(xPos + size / 2.0, yPos, xPos + size / 2.0, yPos + size);
          break;
      default:
        
    }
  }
  p.noFill();
  p.stroke(100);
  p.strokeWeight(1);
  p.rect(xPos, yPos, size, size);
}

function createSketch() {
  var state = {
    contents: {
      grid: createGrid(10),
      gridSize: 10,
      tileSize: 50,
      collapsed: false
    }
  };
  return function (p) {
    p.setup = (function () {
        var s = state.contents;
        p.createCanvas(Math.imul(s.gridSize, s.tileSize), Math.imul(s.gridSize, s.tileSize));
        p.frameRate(10.0);
      });
    p.draw = (function () {
        var s = state.contents;
        p.background(255);
        s.grid.forEach(function (row, y) {
              row.forEach(function (tile, x) {
                    drawTile(p, tile, x, y, s.tileSize);
                  });
            });
        if (s.collapsed) {
          return ;
        }
        var match = getMinEntropyTile(s.grid);
        if (match !== undefined) {
          var y = match[1];
          var x = match[0];
          var tile = Core__Option.getOr(Core__Option.flatMap(s.grid[y], (function (row) {
                      return row[x];
                    })), {
                index: -1,
                options: []
              });
          var newTile = collapseTile(tile, p);
          var newGrid = s.grid.map(function (row, rowY) {
                if (rowY === y) {
                  return row.map(function (t, colX) {
                              if (colX === x) {
                                return newTile;
                              } else {
                                return t;
                              }
                            });
                } else {
                  return row;
                }
              });
          var propagatedGrid = propagateConstraints(newGrid, x, y);
          state.contents = {
            grid: propagatedGrid,
            gridSize: s.gridSize,
            tileSize: s.tileSize,
            collapsed: s.collapsed
          };
          return ;
        }
        state.contents = {
          grid: s.grid,
          gridSize: s.gridSize,
          tileSize: s.tileSize,
          collapsed: true
        };
        console.log("WFC complete!");
      });
    p.mousePressed = (function () {
        state.contents = {
          grid: createGrid(state.contents.gridSize),
          gridSize: state.contents.gridSize,
          tileSize: state.contents.tileSize,
          collapsed: false
        };
      });
  };
}

export {
  tileColors ,
  adjacencyRules ,
  createGrid ,
  getMinEntropyTile ,
  collapseTile ,
  propagateConstraints ,
  drawTile ,
  createSketch ,
}
/* No side effect */
